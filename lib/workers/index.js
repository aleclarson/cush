// Generated by CoffeeScript 2.3.0
var broadcast, cp, defer, events, getWorkerForPack, log, path, pending, request, requestId, workers;

path = require('path');

log = require('lodge').debug('cush');

cp = require('child_process');

// Pending requests
pending = {};

// Send a message and wait for a response.
requestId = 1;

request = function(msg) {
  var id, req;
  id = requestId++;
  this.send(['request', id, msg]);
  pending[id] = req = defer();
  return req.promise;
};

workers = (function() {
  var config, count, env, execArgv, i, inspectIdx, j, onMessage, ref, results, worker, workerPath;
  workerPath = path.join(__dirname, 'worker.js');
  count = process.env.CUSH_WORKERS;
  count = count ? parseInt(count) : require('physical-cpu-count');
  onMessage = function(msg) {
    var handler;
    if (handler = events[msg[0]]) {
      return handler(msg[1], msg[2], msg[3]);
    } else {
      return log.warn('Unhandled worker message:', msg);
    }
  };
  env = Object.assign({}, process.env);
  config = {env};
  inspectIdx = process.execArgv.findIndex(function(arg) {
    return arg.startsWith('--inspect');
  });
  // When inspecting the main process, limit the workers to 1
  // and ensure the worker uses a different port.
  if (inspectIdx !== -1) {
    config.execArgv = execArgv = process.execArgv.slice();
    execArgv[inspectIdx] += '=9230';
    count = 1;
  }
  results = [];
  for (i = j = 0, ref = count; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
    env.WORKER_ID = i + 1;
    worker = cp.fork(workerPath, process.argv, config);
    worker.request = request;
    worker.packCount = 0;
    results.push(worker.on('message', onMessage));
  }
  return results;
})();

events = {
  response: function(id, error, result) {
    var req;
    req = pending[id];
    delete pending[id];
    if (error) {
      return req.reject(error);
    } else {
      return req.resolve(result);
    }
  }
};

module.exports = {
  loadBundle: function(bundle) {
    return broadcast([
      'loadBundle',
      {
        id: bundle.id,
        dev: bundle.dev,
        root: bundle.root.path,
        target: bundle.target,
        config: bundle._config,
        plugins: bundle._workers
      }
    ]);
  },
  loadAsset: function(asset) {
    var pack, worker;
    worker = getWorkerForPack(pack = asset.owner);
    return worker.request(['loadAsset', asset.name, pack.path, pack.bundle.id]);
  },
  dropPackage: function(pack) {
    var worker;
    if (worker = pack.worker) {
      worker.send(['dropPackage', pack.path, pack.bundle.id]);
      worker.packCount -= 1;
      pack.worker = null;
    }
  },
  dropBundle: function(bundle) {
    return broadcast(['dropBundle', bundle.id]);
  },
  printStats: async function(bundle) {
    var j, len, msg, worker;
    msg = ['printStats', bundle.id];
    for (j = 0, len = workers.length; j < len; j++) {
      worker = workers[j];
      await worker.request(msg);
    }
  }
};


// Helpers

// Send a message to all workers.
broadcast = function(msg) {
  var j, len, worker;
  for (j = 0, len = workers.length; j < len; j++) {
    worker = workers[j];
    worker.send(msg);
  }
};

// Each package gets a dedicated worker to avoid loading
// and configuring any packages more than once.
getWorkerForPack = (function() {
  var lowestPackCount;
  lowestPackCount = function(curr, worker) {
    if (!curr || curr.packCount > worker.packCount) {
      return worker;
    }
    return curr;
  };
  return function(pack) {
    var worker;
    if (!(worker = pack.worker)) {
      pack.worker = worker = workers.reduce(lowestPackCount);
      worker.packCount += 1;
    }
    return worker;
  };
})();

defer = function() {
  var args;
  args = null;
  return {
    promise: new Promise(function() {
      return args = [...arguments];
    }),
    resolve: args[0],
    reject: args[1]
  };
};
