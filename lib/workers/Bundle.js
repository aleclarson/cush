// Generated by CoffeeScript 2.3.0
var Bundle, ErrorTracer, VERBOSE, elaps, empty, extRegex, fs, getModule, log, mapSources, path, snipSyntaxError, vm, wrapPlugin;

snipSyntaxError = require('../utils/snipSyntaxError');

ErrorTracer = require('../utils/ErrorTracer');

mapSources = require('../utils/mapSources');

getModule = require('../utils/getModule');

extRegex = require('../utils/extRegex');

elaps = require('elaps');

path = require('path');

log = require('lodge').debug('cush');

fs = require('saxon');

vm = require('vm');

empty = [];

VERBOSE = process.env.VERBOSE === '1';

elaps.log = log;

Bundle = class Bundle {
  constructor(props) {
    this.id = props.id;
    this.dev = props.dev;
    this.root = props.root;
    this.target = props.target;
    this.packages = {};
    this._events = {};
    this._config = props.config;
    this._extRE = null;
    this._timers = {};
    this._resetTimers();
    this._configure(props);
  }

  relative(filename) {
    return filename.slice(this.root.length + 1);
  }

  // The "transform" phase occurs after reading the asset.
  transform(exts, fn) {
    var hook;
    hook = (asset, pack) => {
      var lap, result;
      result = fn(asset, pack);
      if (result && result.map) {
        lap = this._timed('source maps').start();
        mapSources(asset, result);
        lap.stop();
      }
    };
    hook.source = this._getSource(1);
    if (Array.isArray(exts)) {
      return exts.forEach((ext) => {
        return this.hook('asset' + ext, hook);
      });
    } else {
      return this.hook('asset' + exts, hook);
    }
  }

  _configure({plugins, parsers}) {
    var i, len, plugin;
    this._config.parsers.forEach((filename) => {
      var ext, parse, ref;
      ref = require(filename);
      for (ext in ref) {
        parse = ref[ext];
        parse.source = {
          path: filename
        };
        this.hook('parse' + ext, parse);
      }
    });
    for (i = 0, len = plugins.length; i < len; i++) {
      plugin = plugins[i];
      plugin = plugin.func ? wrapPlugin(plugin).call(this) : require(plugin.path);
      plugin.call(this);
    }
    this._extRE = extRegex(this.get('exts') || empty, this.get('known exts') || empty);
  }

  _parseExt(name) {
    var match;
    if (match = this._extRE.exec(name)) {
      return match[0];
    }
  }

  // Run hooks for a module.
  async _loadAsset(name, root) {
    var asset, assetExt, assetPath, content, err, event, ext, hook, hookTime, i, j, k, lap, len, len1, len2, loadTime, pack, ref, ref1, ref2;
    if (!(pack = this.packages[root])) {
      lap = this._timed('load packages').start();
      VERBOSE && (loadTime = elaps('load package %O', this.relative(root)));
      this.packages[root] = pack = JSON.parse((await fs.read(path.join(root, 'package.json'))));
      pack.path = root;
      if (event = this._events.package) {
        await Promise.all(event.hooks.map(function(hook) {
          return hook(pack);
        }));
      }
      VERBOSE && loadTime.stop(true);
      lap.stop();
    }
    if (!(assetExt = this._parseExt(name))) {
      throw Error('Unknown extension: ' + name);
    }
    assetPath = path.join(root, name);
    VERBOSE && (loadTime = elaps('load asset %O', this.relative(assetPath)));
    lap = this._timed('read files').start();
    content = (await fs.read(assetPath));
    lap.stop();
    lap = this._timed('load assets').start();
    asset = {
      ext: assetExt,
      path: assetPath,
      content: content,
      deps: null,
      map: null
    };
    try {
      while (asset.ext !== ext) {
        ext = asset.ext;
        if (!(event = this._events['asset' + ext])) {
          break;
        }
        ref = event.hooks;
        for (i = 0, len = ref.length; i < len; i++) {
          hook = ref[i];
          VERBOSE && (hookTime = this._timedHook(hook).start());
          await hook(asset, pack);
          VERBOSE && hookTime.stop();
          if (asset.ext !== ext) {
            break;
          }
        }
      }
    } catch (error) {
      err = error;
      if (err.line != null) {
        ErrorTracer(asset)(err, this.relative(assetPath));
        err.snippet = snipSyntaxError(asset.content, err);
      }
      throw err;
    }
    if (event = this._events['parse' + ext]) {
      ref1 = event.hooks;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        hook = ref1[j];
        VERBOSE && (hookTime = this._timedHook(hook).start());
        await hook(asset, pack);
        VERBOSE && hookTime.stop();
      }
    }
    if (event = this._events['asset']) {
      ref2 = event.hooks;
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        hook = ref2[k];
        VERBOSE && (hookTime = this._timedHook(hook).start());
        await hook(asset, pack);
        VERBOSE && hookTime.stop();
      }
    }
    VERBOSE && loadTime.stop(true);
    lap.stop();
    return {
      ext: asset.ext,
      content: asset.content,
      deps: asset.deps,
      map: asset.map
    };
  }

  _timed(id) {
    var base;
    return (base = this._timers)[id] || (base[id] = elaps.lazy());
  }

  _timedHook(hook) {
    var base, name1;
    return (base = this._timers)[name1 = hook.source.path] || (base[name1] = elaps.lazy('hook %O', path.relative('', hook.source.path)));
  }

  _printStats() {
    var id, ref, timer;
    if (/\bcush\b/.test(process.env.DEBUG)) {
      log('');
      log('worker #' + process.env.WORKER_ID);
      this._timed('read files').msg = 'read %n files in %t';
      this._timed('load assets').msg = 'loaded %n assets in %t';
      this._timed('load packages').msg = 'loaded %n packages in %t';
      this._timed('source maps').msg = 'source map tracing took %t';
      ref = this._timers;
      for (id in ref) {
        timer = ref[id];
        timer.print();
      }
    }
    this._resetTimers();
  }

  _resetTimers() {
    this._timers = {
      'read files': null,
      'load assets': null,
      'load packages': null,
      'source maps': null
    };
  }

};

require('../Bundle/PluginMixin')(Bundle);

module.exports = Bundle;

wrapPlugin = function(plugin) {
  var ctx, module, script;
  ctx = {};
  if (plugin.path) {
    module = getModule(plugin.path);
    ctx.require = function(id) {
      return module.require(id);
    };
  } else {
    ctx.require = require;
  }
  script = `function plugin() {return ${plugin.func}}`;
  vm.runInNewContext(script, ctx, {
    filename: plugin.path,
    lineOffset: plugin.line,
    timeout: 120 * 1000
  });
  return ctx.plugin;
};
