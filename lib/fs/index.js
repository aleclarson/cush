// Generated by CoffeeScript 2.3.0
var Package, concat, cush, each, evalFile, excludeLocals, findPackage, fs, isObject, nodeModulesExpr, nodeModulesRE, noop, packages, path, readPackage, streams, unloadFile, watchPackage, wch;

({concat, each, evalFile, findPackage} = require('../utils'));

isObject = require('is-object');

Package = require('./Package');

cush = require('cush');

noop = require('noop');

path = require('path');

wch = require('wch');

fs = require('saxon/sync');

// Packages by [name].get(version)
cush.packages = packages = Object.create(null);

// Get/load package by absolute path
cush.package = function(root, data) {
  var pack, versions;
  if (!path.isAbsolute(root)) {
    throw Error(`Package root must be absolute: '${root}'`);
  }
  if (data == null) {
    data = evalFile(path.join(root, 'package.json'));
  }
  if (!data.name) {
    throw Error('Package has no "name" field: ' + root);
  }
  if (!data.version) {
    throw Error('Package has no "version" field: ' + root);
  }
  if (versions = packages[data.name]) {
    if (pack = versions.get(data.version)) {
      return pack;
    }
  } else {
    packages[data.name] = versions = new Map;
  }
  versions.set(data.version, pack = new Package(root, data));
  // Avoid crawling/watching local packages.
  each(data.dependencies, excludeLocals, pack);
  each(data.devDependencies, excludeLocals, pack);
  // Any package whose "real" path is in a
  // 'node_modules' directory is *not* watched.
  root = fs.follow(root, true);
  if (!nodeModulesRE.test(root)) {
    watchPackage(pack, root);
  }
  return pack;
};


// Internal

streams = new Map;

nodeModulesRE = /(^|\/)node_modules\//;

nodeModulesExpr = wch.expr({
  only: ['/node_modules/*/package.json', '/node_modules/@*/*/package.json'],
  type: 'f'
});

excludeLocals = function(dep) {
  if (dep.indexOf('file:./') === 0) {
    this.exclude.push(dep.slice(7) + '/**');
  }
};

watchPackage = function(pack, root) {
  var skip, stream;
  pack.watched = true;
  // ignored files
  skip = concat(pack.exclude, cush.config('exclude'));
  stream = wch.stream(root, {
    expr: ['anyof', nodeModulesExpr, wch.expr({skip})],
    fields: ['name', 'exists', 'new'],
    since: 1 + Math.ceil(Date.now() / 1000)
  });
  stream.on('data', function(evt) {
    var dep, file;
    if (evt.name === '/') {
      return;
    }
    if (nodeModulesRE.test(evt.name)) {
      // Skip new packages.
      if (evt.new) {
        return;
      }
      // Skip unused packages.
      evt.name = path.dirname(evt.name);
      if (!(dep = pack.files[evt.name])) {
        return;
      }
      // Skip packages with unchanged name/version.
      if (evt.exists && readPackage(dep)) {
        return;
      }
      // Unload the package if we own it.
      if (pack === dep.parent) {
        return dep._unload();
      }
    } else {
      evt.pack = pack;
      process.nextTick(cush.emit, 'change', evt);
      if (evt.new) {
        pack.files[evt.name] = true;
        return;
      }
      if (!pack.parent && evt.name === 'package.json') {
        readPackage(pack);
      }
      file = pack.files[evt.name];
      if (isObject(file)) {
        // Rebuild bundles that use this file.
        pack.bundles.forEach(function(bundle) {
          return bundle._unloadModule(file.id);
        });
        if (evt.exists) {
          return unloadFile(file);
        }
        // Mark the file as deleted.
        file.id = 0;
      // Keep modified files in memory.
      } else if (evt.exists) {
        return;
      }
    }
    // Remove deleted files and stale packages.
    return delete pack.files[evt.name];
  });
  stream.on('error', function(err) {
    return cush.emit('error', {
      message: 'An error occurred on a watch stream',
      error: err,
      root: root,
      pack: pack
    });
  });
  streams.set(pack, stream);
};

// Unload the file's content.
unloadFile = function(file) {
  if (file.content !== null) {
    file.ext = path.extname(file.name);
    file.content = null;
    file.time = Date.now();
    file.map = null;
  }
};

// Returns false if "package.json" has a new name/version or does not exist.
readPackage = function(pack) {
  var data, err, name, version;
  ({name, version} = pack.data);
  try {
    data = evalFile(path.join(pack.path, 'package.json'));
    if ((name === data.name) && (version === data.version)) {
      pack.data = data;
      return true;
    }
    return false;
  } catch (error) {
    err = error;
    // Be forgiving about malformed JSON.
    return err.name === 'SyntaxError';
  }
};

// Reset the package cache (for testing).
Object.defineProperty(cush, '_resetPackages', {
  value: function() {
    cush.packages = packages = Object.create(null);
    streams.forEach(function(s) {
      return s.destroy();
    });
    streams.clear();
  }
});

// Remove a package from the cache, and stop watching it.
Package.prototype._unload = function() {
  var file, name, now, ref, stream, versions;
  this._unload = noop;
  // Update the times of our files,
  // and unlink our dependencies.
  now = Date.now();
  ref = this.files;
  for (name in ref) {
    file = ref[name];
    if (!isObject(file)) {
      continue;
    }
    if (file.name) {
      file.time = now;
      continue;
    }
    file.users.delete(this);
    if (this === file.parent) {
      file._unload();
    }
  }
  // Destroy the file cache.
  this.files = null;
  // Update our dependent packages.
  name = path.join('node_modules', this.data.name);
  this.users.forEach(function(user) {
    return delete user.files[name];
  });
  // Invalidate any bundles.
  if (this.bundles.size) {
    this.bundles.forEach(function(bundle) {
      bundle.valid = false; // Disable automatic rebuilds (temporarily).
      bundle._result = null;
    });
  }
  // Remove from the package cache.
  versions = packages[this.data.name];
  versions.delete(this.data.version);
  if (versions.size === 0) {
    delete packages[this.data.name];
  }
  // Stop watching.
  if (stream = streams.get(this)) {
    streams.delete(this);
    stream.destroy();
  }
};
