// Generated by CoffeeScript 2.3.0
var Package, concat, crawl, cush, isObject, matchFile, nextFileId, path, tryPackage;

({concat} = require('../utils'));

isObject = require('is-object');

crawl = require('./crawl');

cush = require('cush');

path = require('path');

nextFileId = 1;

Package = class Package {
  constructor(path1, data) {
    this.path = path1;
    this.data = data;
    this.files = Object.create(null);
    this.users = new Set;
    this.parent = null;
    this.bundles = new Set;
    this.exclude = [];
    this.crawled = false;
  }

  crawl() {
    if (!this.crawled) {
      this.crawled = true;
      return crawl(this.path, this.files, {
        skip: concat(this.exclude, cush.config('exclude'))
      });
    }
  }

  file(name) {
    var file;
    file = this.files[name];
    if (file === void 0) {
      return null;
    }
    if (typeof file === 'string') {
      file = this.files[name = file];
    }
    if (file === true) {
      this.files[name] = file = {
        id: nextFileId++,
        name: name,
        ext: path.extname(name),
        content: null,
        time: null,
        map: null
      };
    }
    return file;
  }

  resolve(file) {
    return path.resolve(this.path, typeof file === 'string' ? file : file.name);
  }

  search(name, target, exts) {
    var ext, pref;
    if (ext = path.extname(name)) {
      // prefer target-specific modules
      pref = name.slice(0, -ext.length) + '.' + target + ext;
      return this.file(pref) || this.file(name);
    }
    // resolve the file extension
    // might be a directory name
    return matchFile(name, target, exts, this) || matchFile(name + '/index', target, exts, this);
  }

  require(name) {
    var pack;
    name = path.join('node_modules', name);
    if (pack = this.files[name]) {
      return pack;
    }
    if (pack = tryPackage(path.join(this.path, name))) {
      pack.parent || (pack.parent = this);
      pack.users.add(this);
      this.files[name] = pack;
      return pack;
    }
    return null;
  }

};

module.exports = Package;


// Internal

// TODO: watch the package.json of 'bad packages'
tryPackage = function(root) {
  var err;
  try {
    return cush.package(root);
  } catch (error) {
    err = error;
    cush.emit('warning', {
      code: 'BAD_PACKAGE',
      message: err.message,
      package: root
    });
  }
};

// Resolve a filename that has no extension.
matchFile = function(id, target, exts, pack) {
  var ext, file, i, len, pref;
  // prefer target-specific modules
  pref = id + '.' + target;
  for (i = 0, len = exts.length; i < len; i++) {
    ext = exts[i];
    file = pack.file(pref + ext) || pack.file(id + ext);
    if (file) {
      return file;
    }
  }
};
