// Generated by CoffeeScript 2.3.0
var BundleEvent, getCallSite, merge, mixin, setPath;

BundleEvent = require('./Event');

getCallSite = require('../utils/getCallSite');

merge = require('../utils/merge');

// This mixin provides the methods used by plugins.
// These methods are available both in and out of workers.
mixin = {
  has: function(path) {
    var i, j, last, obj, ref;
    if (typeof path === 'string') {
      path = path.split('.');
    }
    obj = this._config;
    last = path.length - 1;
    for (i = j = 0, ref = last; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      obj = obj[path[i]];
      if (!obj || obj.constructor !== Object) {
        return false;
      }
    }
    return obj[path[last]] !== void 0;
  },
  get: function(path, elseVal) {
    var i, j, last, obj, prev, ref, val;
    if (typeof path === 'string') {
      path = path.split('.');
    }
    obj = this._config;
    last = path.length - 1;
    for (i = j = 0, ref = last; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      prev = obj;
      obj = prev[path[i]];
      if (obj == null) {
        break;
      }
      if (obj.constructor !== Object) {
        path = path.slice(0, i + 1).join('.');
        throw TypeError(`'${path}' is not an object`);
      }
    }
    val = obj && obj[path[last]];
    if (arguments.length === 2) {
      return val != null ? val : setPath(obj || prev, path.slice(i), elseVal);
    }
    return val;
  },
  set: function(path, val) {
    if (typeof path === 'string') {
      path = path.split('.');
    }
    setPath(this._config, path, val);
    return this;
  },
  merge: function(path, val) {
    var obj;
    if (arguments.length === 2) {
      if (typeof path === 'string') {
        path = path.split('.');
      }
      obj = this.get(path);
    } else {
      obj = this._config;
      val = path;
    }
    if (obj && obj.constructor === val.constructor) {
      merge(obj, val);
    } else if (arguments.length === 2) {
      obj = this.get(path.slice(0, -1), {});
      obj[path[path.length - 1]] = val;
    } else {
      throw TypeError('Cannot merge that value: ' + (JSON.stringify(value) || Object.prototype.toString.call(value)));
    }
    return this;
  },
  hook: function(id, hook) {
    var event;
    if (!(event = this._events[id])) {
      this._events[id] = event = new BundleEvent;
    }
    if (typeof hook === 'function') {
      hook.source || (hook.source = this._getSource(1));
      event.add(hook);
      return this;
    }
    return event;
  },
  hookLeft: function(id, hook) {
    var event;
    if (typeof hook !== 'function') {
      throw TypeError('`hook` must be a function');
    }
    if (!(event = this._events[id])) {
      this._events[id] = event = new BundleEvent;
    }
    hook.source || (hook.source = this._getSource(1));
    event.add(hook, -1);
    return this;
  },
  hookRight: function(id, hook) {
    var event;
    if (typeof hook !== 'function') {
      throw TypeError('`hook` must be a function');
    }
    if (!(event = this._events[id])) {
      this._events[id] = event = new BundleEvent;
    }
    hook.source || (hook.source = this._getSource(1));
    event.add(hook, 1);
    return this;
  },
  _getSource: function(offset = 0) {
    var frame;
    frame = getCallSite(1 + offset);
    return {
      path: frame.getFileName(),
      line: frame.getLineNumber()
    };
  }
};

module.exports = function(ctr) {
  return Object.assign(ctr.prototype, mixin);
};

setPath = function(obj, path, val) {
  var i, j, last, prev, ref;
  last = path.length - 1;
  for (i = j = 0, ref = last; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
    prev = obj;
    obj = prev[path[i]];
    if (obj == null) {
      prev[path[i]] = obj = {};
    } else if (obj.constructor !== Object) {
      path = path.slice(0, i + 1).join('.');
      throw TypeError(`'${path}' is not an object`);
    }
  }
  obj[path[last]] = val;
  return val;
};
