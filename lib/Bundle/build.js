// Generated by CoffeeScript 2.3.1
var Resolver, build, cush, each, elaps, loadAsset, mapFlush, printStats, readAsset, resolved;

({loadAsset, printStats} = require('../workers'));

({each} = require('../utils'));

Resolver = require('./Resolver');

elaps = require('elaps');

cush = require('cush');

resolved = Promise.resolve();

build = async function(bundle, state) {
  var BUSY, IDLE, assetHook, assets, concatTimer, dropUnusedPackage, loaded, missing, ownerHook, packages, queue, readTimer, resolve, resolveTimer, resolvedCount, result;
  assets = []; // ordered assets
  loaded = []; // sparse asset map for deduping
  packages = []; // ordered packages
  queue = []; // queued assets
  missing = []; // missing dependencies
  resolve = Resolver(bundle, queue, missing);
  resolvedCount = 0;
  readTimer = elaps.lazy();
  resolveTimer = elaps.lazy();
  assetHook = bundle.hook('asset');
  ownerHook = bundle.hook('package');
  loadAsset = async function(asset) {
    var lap, owner;
    resolvedCount += 1;
    if (loaded[asset.id]) {
      return;
    }
    loaded[asset.id] = true;
    assets.push(asset);
    ({owner} = asset);
    if (packages.indexOf(owner) === -1) {
      packages.push(owner);
      owner.missedAsset = false;
      owner.missedPackage = false;
      ownerHook.emit(owner, state);
    }
    // Wait for the load queue to be cleared.
    await resolved;
    // Read the asset.
    if (asset.content === null) {
      lap = readTimer.start();
      await readAsset(asset);
      lap.stop();
    }
    // Resolve its dependencies.
    if (asset.deps) {
      lap = resolveTimer.start();
      await resolve(asset);
      lap.stop();
    }
    // Let plugins inspect/alter the asset.
    assetHook.emit(asset, state);
  };
  // Load the main module.
  await loadAsset(bundle.main);
  ({IDLE, BUSY} = require('../Bundle').Status);
  // Keep loading modules until stopped or finished.
  while (bundle.status === BUSY && queue.length) {
    await mapFlush(queue, loadAsset);
  }
  // Exit early for cancelled builds.
  if (bundle.status !== BUSY) {
    return null;
  }
  // Cancel the build if dependencies are missing.
  if (missing.length) {
    state.missing = missing;
    bundle.status = IDLE;
    return null;
  }
  readTimer.print('loaded %n assets in %t');
  resolveTimer.print('resolved %O dependencies in %t', resolvedCount);
  printStats(bundle);
  dropUnusedPackage = function(pack) {
    if (packages.indexOf(pack) === -1) {
      return pack._unload();
    }
  };
  // Purge unused packages.
  each(bundle.packages, function(versions, name) {
    return versions.forEach(dropUnusedPackage);
  });
  concatTimer = elaps('concatenated %O assets in %t', assets.length);
  // Concatenate the assets.
  result = (await bundle._concat(assets, packages));
  if (/\bcush\b/.test(process.env.DEBUG)) {
    setImmediate(function() {
      return concatTimer.stop(true);
    });
  }
  return result;
};

module.exports = build;

// Combine all promises in the given queue before clearing it.
mapFlush = function(queue, iter) {
  var promise;
  promise = Promise.all(queue.map(iter));
  queue.length = 0;
  return promise;
};

readAsset = async function(asset) {
  var prev;
  if (asset.deps) {
    prev = Object.create(null);
    asset.deps.forEach(function(dep) {
      prev[dep.ref] = dep.asset;
    });
  }
  await asset._load();
  if (prev && asset.deps) {
    return asset.deps.forEach(function(dep) {
      dep.asset = prev[dep.ref] || null;
    });
  }
};
