// Generated by CoffeeScript 2.3.0
var Resolver, build, cush, drain, loadFile, parseImports;

Resolver = require('./Resolver');

loadFile = require('../fs/loadFile');

cush = require('cush');

build = async function(bundle, opts) {
  var files, loadModule, modules, packages, pending, resolve, timestamp;
  timestamp = Date.now();
  bundle.missed = [];
  files = []; // ordered files
  packages = []; // ordered packages
  modules = []; // sparse module map (file => module)
  pending = [];
  resolve = Resolver(bundle, pending);
  loadModule = async function(mod) {
    var file, pack;
    if (!mod || modules[mod.file.id]) {
      return;
    }
    ({file, pack} = mod);
    // Cache the module.
    modules[file.id] = mod;
    files.push(file);
    // Cache its package.
    if (packages.indexOf(pack) === -1) {
      packages.push(pack);
      if (!bundle.packages[pack.id]) {
        pack.bundles.add(bundle);
        await bundle._loadPackage(pack);
      }
    }
    // Read file, then apply global plugins.
    if (file.content === null) {
      await loadFile(file, mod.pack);
    }
    // Apply bundle plugins.
    if (mod.content === null) {
      mod.content = file.content;
      mod.map = file.map;
      mod.ext = file.ext;
      await bundle._loadModule(mod);
      await parseImports(mod);
    }
    // Resolve any imports.
    if (mod.deps) {
      return (await resolve(mod));
    }
  };
  // Load the main module.
  await loadModule(bundle.main);
  // Keep loading modules until stopped or finished.
  while (bundle.valid && pending.length) {
    await Promise.all(((await drain(pending))).map(loadModule));
  }
  // Update the build time.
  bundle.time = timestamp;
  if (!bundle.valid || bundle.missed.length) {
    return null;
  }
  // Purge unused packages.
  bundle.packages.forEach(function(pack) {
    return ~packages.indexOf(pack) || bundle._dropPackage(pack);
  });
  bundle.files = files;
  bundle.modules = modules;
  bundle.packages = packages;
  // Create the bundle string.
  return bundle._joinModules();
};

module.exports = build;

// Wrap the given queue with Promise.all before emptying it.
drain = function(queue) {
  var promise;
  promise = Promise.all(queue);
  queue.length = 0;
  return promise;
};

// Parse the imports of a module, and reuse old resolutions.
parseImports = async function(mod) {
  var prev;
  if (mod.deps) {
    prev = Object.create(null);
    mod.deps.forEach(function(dep) {
      prev[dep.ref] = dep.module;
    });
  }
  mod.deps = (await cush._parseImports(mod));
  if (prev) {
    return mod.deps.forEach(function(dep) {
      dep.module = prev[dep.ref] || null;
    });
  }
};
