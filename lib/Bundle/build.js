// Generated by CoffeeScript 2.3.0
var Resolver, build, cush, each, elaps, loadAsset, mapFlush, printStats, readAsset, resolved;

({loadAsset, printStats} = require('../workers'));

({each} = require('../utils'));

Resolver = require('./Resolver');

elaps = require('elaps');

cush = require('cush');

resolved = Promise.resolve();

build = async function(bundle, state) {
  var assetHook, assets, dropUnusedPackage, loaded, missing, ownerHook, packages, queue, readTimer, resolve, resolveTimer, resolvedCount, result, t3, timestamp;
  timestamp = Date.now();
  assets = []; // ordered assets
  loaded = []; // sparse asset map for deduping
  packages = []; // ordered packages
  queue = []; // queued assets
  missing = []; // missing dependencies
  resolve = Resolver(bundle, queue, missing);
  resolvedCount = 0;
  readTimer = elaps.lazy();
  resolveTimer = elaps.lazy();
  assetHook = bundle.hook('asset');
  ownerHook = bundle.hook('package');
  loadAsset = async function(asset) {
    var lap, owner;
    resolvedCount += 1;
    if (loaded[asset.id]) {
      return;
    }
    loaded[asset.id] = true;
    assets.push(asset);
    ({owner} = asset);
    if (packages.indexOf(owner) === -1) {
      packages.push(owner);
      owner.missedAsset = false;
      owner.missedPackage = false;
      ownerHook.emit(owner, state);
    }
    // Wait for the load queue to be cleared.
    await resolved;
    // Read the asset.
    if (asset.content === null) {
      lap = readTimer.start();
      await readAsset(asset);
      lap.stop();
    }
    // Resolve its dependencies.
    if (asset.deps) {
      lap = resolveTimer.start();
      await resolve(asset);
      lap.stop();
    }
    // Let plugins inspect/alter the asset.
    assetHook.emit(asset, state);
  };
  // Load the main module.
  await loadAsset(bundle.main);
  // Keep loading modules until stopped or finished.
  while (bundle.valid && queue.length) {
    await mapFlush(queue, loadAsset);
  }
  // The bundle is invalid if dependencies are missing.
  if (missing.length) {
    state.missing = missing;
    bundle._invalidate();
  }
  if (!bundle.valid) {
    return null;
  }
  // Update the build time.
  bundle.time = timestamp;
  readTimer.print('loaded %n assets in %t');
  resolveTimer.print('resolved %O dependencies in %t', resolvedCount);
  printStats(bundle);
  dropUnusedPackage = function(pack) {
    if (packages.indexOf(pack) === -1) {
      return pack._unload();
    }
  };
  // Purge unused packages.
  each(bundle.packages, function(versions, name) {
    return versions.forEach(dropUnusedPackage);
  });
  // Concatenate the assets.
  t3 = elaps('concatenate assets');
  result = (await bundle._concat(assets, packages));
  t3.stop();
  return result;
};

module.exports = build;

// Combine all promises in the given queue before clearing it.
mapFlush = function(queue, iter) {
  var promise;
  promise = Promise.all(queue.map(iter));
  queue.length = 0;
  return promise;
};

readAsset = async function(asset) {
  var prev;
  if (asset.deps) {
    prev = Object.create(null);
    asset.deps.forEach(function(dep) {
      prev[dep.ref] = dep.asset;
    });
  }
  await asset._load();
  if (prev && asset.deps) {
    return asset.deps.forEach(function(dep) {
      dep.asset = prev[dep.ref] || null;
    });
  }
};
