// Generated by CoffeeScript 2.3.0
var Bundle, BundleEvent, build, cush, noEarlier, noop, path;

BundleEvent = require('./Event');

build = require('./build');

noop = require('noop');

path = require('path');

cush = require('cush');

Bundle = class Bundle {
  constructor(dev, target) {
    this.id = null; // bundle identifier
    this.dev = dev; // development mode
    this.target = target; // targeted platform
    this.root = null; // the root package
    this.main = null; // the main module
    this.exts = null; // implicit file extensions
    this.time = 0; // time of last build
    this.valid = false; // not outdated?
    this.elapsed = null; // time spent building
    this.files = []; // ordered files
    this.packages = []; // ordered packages
    this.modules = []; // sparse module map
    this.missed = []; // missing dependencies
    this._config = null; // plugin config
    this._events = null; // event hooks
    this._format = null; // bundle format
    this._result = null; // build promise
  }

  read() {
    return this._result || (this._result = this._build());
  }

  destroy() {
    this._rev = 0; // cancel the current build
    this.read = noop.val(Promise.resolve()); // prevent future builds
    this.packages.forEach(this._dropPackage.bind(this)); // remove unused packages
    this._project.drop(this); // remove unused projects
    return this;
  }

  relative(mod) {
    if (!mod || !mod.pack) {
      throw Error('Expected a module');
    }
    return mod.pack.resolve(mod.file).slice(this.root.path.length + 1);
  }

  has(path) {
    var i, j, last, obj, ref;
    if (typeof path === 'string') {
      path = path.split('.');
    }
    obj = this._config;
    last = path.length - 1;
    for (i = j = 0, ref = last; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      obj = obj[path[i]];
      if (!obj || typeof obj !== 'object') {
        return false;
      }
    }
    return obj[path[last]] !== void 0;
  }

  get(path) {
    var i, j, last, obj, ref;
    if (typeof path === 'string') {
      path = path.split('.');
    }
    obj = this._config;
    last = path.length - 1;
    for (i = j = 0, ref = last; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      obj = obj[path[i]];
      if (obj == null) {
        return;
      }
      if (obj.constructor !== Object) {
        path = path.slice(0, i + 1).join('.');
        throw TypeError(`'${path}' is not an object`);
      }
    }
    return obj[path[last]];
  }

  set(path, val) {
    var i, j, last, obj, prev, ref;
    if (typeof path === 'string') {
      path = path.split('.');
    }
    obj = this._config;
    last = path.length - 1;
    for (i = j = 0, ref = last; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      prev = obj;
      obj = prev[path[i]];
      if (obj == null) {
        prev[path[i]] = obj = {};
      } else if (obj.constructor !== Object) {
        path = path.slice(0, i + 1).join('.');
        throw TypeError(`'${path}' is not an object`);
      }
    }
    obj[path[last]] = val;
    return this;
  }

  getSourceMapURL(value) {
    return '\n\n' + this._wrapSourceMapURL(typeof value === 'string' && value + '.map' || value.toUrl());
  }

  hook(id, hook) {
    var event;
    if (!(event = this._events[id])) {
      this._events[id] = event = new BundleEvent;
    }
    if (typeof hook === 'function') {
      event.add(hook);
      return this;
    }
    return event;
  }

  hookLeft(id, hook) {
    var event;
    if (typeof hook !== 'function') {
      throw TypeError('`hook` must be a function');
    }
    if (!(event = this._events[id])) {
      this._events[id] = event = new BundleEvent;
    }
    event.add(hook, -1);
    return this;
  }

  hookRight(id, hook) {
    var event;
    if (typeof hook !== 'function') {
      throw TypeError('`hook` must be a function');
    }
    if (!(event = this._events[id])) {
      this._events[id] = event = new BundleEvent;
    }
    event.add(hook, 1);
    return this;
  }

  hookModules(exts, hook) {
    if (Array.isArray(exts)) {
      return exts.forEach((ext) => {
        return this.hook('module' + ext, hook);
      });
    } else {
      return this.hook('module' + exts, hook);
    }
  }

  _configure() {
    var config, err, events, ref;
    this._config = {};
    try {
      this._events = events = {};
      if ((ref = this._format.plugins) != null) {
        ref.forEach((plugin) => {
          return plugin.call(this);
        });
      }
      if (config = this._project.config[this._format.name]) {
        config.call(this);
      }
      if (events.config) {
        events.config.emit();
        events.config = null;
      }
    } catch (error) {
      err = error;
      cush.emit('error', {
        message: 'Failed to configure bundle',
        error: err,
        root: this.root.path
      });
      return this;
    }
    if (this.valid) {
      this._invalidate();
    }
    return this;
  }

  async _build() {
    var bundle, err, time;
    try {
      this.valid = true;
      time = process.hrtime();
      bundle = (await build(this));
      if (this.valid) {
        time = process.hrtime(time);
        this.elapsed = Math.ceil(time[0] * 1e3 + time[1] * 1e-6);
        // Force rebuild when dependencies are missing.
        if (this.missed.length) {
          this._invalidate();
        }
      }
      // Return the payload.
      return bundle;
    } catch (error) {
      err = error;
      // Errors are ignored when the next build is automatic.
      if (this.valid) {
        this._invalidate();
        throw err;
      }
    }
  }

  // Invalidate the current build, and disable automatic rebuilds
  // until the next build is triggered manually.
  _invalidate() {
    this.valid = false;
    this._result = null;
  }

  // Invalidate the current build, and trigger an automatic rebuild.
  _rebuild() {
    if (this.valid) {
      this.valid = false;
      this._result = this._result.then(noEarlier(200 + Date.now())).then(this._build.bind(this));
    }
  }

  // Return a Module object for the given file object.
  _getModule(file, pack) {
    var mod;
    if (!(mod = this.modules[file.id])) {
      // New modules are put in the previous build's module cache.
      // When the new build finishes, old modules are released.
      this.modules[file.id] = mod = {
        file,
        pack,
        content: null,
        deps: null, // ordered dependency objects
        map: null, // sourcemap
        ext: null // file extension
      };
    }
    return mod;
  }

  // Run hooks for a module.
  async _loadModule(mod) {
    var event, ext, hooks, i, j, ref;
    ({ext} = mod);
    if (event = this._events['module' + ext]) {
      ({hooks} = event);
      for (i = j = 0, ref = hooks.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        await hooks[i](mod);
        if (mod.ext !== ext) {
          return this._loadModule(mod);
        }
      }
    }
  }

  _unloadModule(id) {
    var mod;
    if (mod = this.modules[id]) {
      mod.content = null;
      return this._rebuild();
    }
  }

  _unloadModules() {
    this._invalidate();
    return this.modules.forEach(function(mod) {
      return mod.content = null;
    });
  }

  // Run hooks for a package.
  _loadPackage(pack) {
    return Promise.all(this._events.package.hooks.map(function(hook) {
      return hook(pack);
    }));
  }

  _dropPackage(pack) {
    pack.bundles.delete(this);
    if (!pack.bundles.size) {
      pack._unload();
    }
    return this;
  }

  _joinModules(modules) {
    throw Error('Bundle format must override `_joinModules`');
  }

  _wrapSourceMapURL(url) {
    throw Error('Bundle format must override `_wrapSourceMapURL`');
  }

};

module.exports = Bundle;

// Create a function that enforces a minimum delay.
noEarlier = function(time) {
  return function() {
    return new Promise(function(resolve) {
      var delay;
      delay = Math.max(0, time - Date.now());
      return delay && setTimeout(resolve, delay) || resolve();
    });
  };
};
