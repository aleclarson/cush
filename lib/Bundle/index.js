// Generated by CoffeeScript 2.3.0
var Asset, Bundle, Emitter, Module, Package, build, cush, dropBundle, empty, evalFile, extRegex, fs, getCallSite, getModule, isObject, loadBundle, log, noEarlier, nodeModulesRE, path, resolvePlugin, tryRequire, uhoh;

({evalFile, extRegex, getCallSite, getModule, uhoh} = require('../utils'));

({loadBundle, dropBundle} = require('../workers'));

isObject = require('is-object');

Emitter = require('@cush/events');

Package = require('./Package');

Module = require('module');

Asset = require('./Asset');

build = require('./build');

cush = require('cush');

path = require('path');

log = require('lodge').debug('cush');

fs = require('saxon/sync');

empty = [];

nodeModulesRE = /\/node_modules\//;

Bundle = (function() {
  class Bundle extends Emitter {
    constructor(opts) {
      super();
      this.id = opts.id;
      this.dev = Boolean(opts.dev);
      this.root = null;
      this.main = null;
      this.target = opts.target;
      this.assets = [];
      this.packages = Object.create(null);
      this.plugins = opts.plugins || [];
      this.parsers = opts.parsers || [];
      this.project = null;
      this.valid = false;
      this.state = null;
      this.time = 0;
      this._result = null;
      this._loading = null;
      this._loadedPlugins = new Set;
      this._nextAssetId = 1;
      this._workers = [];
      this._config = null;
      this._events = null;
      this._extRE = null;
      this._init = opts.init;
    }

    relative(absolutePath) {
      return absolutePath.slice(this.root.path.length + 1);
    }

    resolve(relativePath) {
      return path.resolve(this.root.path, relativePath);
    }

    read() {
      return this._result || (this._result = this._build());
    }

    use(plugins) {
      if (!Array.isArray(plugins)) {
        plugins = [plugins];
      }
      return Promise.all(plugins.map(async(val) => {
        var err, plugin;
        if (Array.isArray(val)) {
          return this.use(val);
        }
        plugin = typeof val === 'string' ? (await resolvePlugin(val, this.main.path())) : val;
        if (!plugin || this._loadedPlugins.has(plugin)) {
          return;
        }
        this._loadedPlugins.add(plugin);
        if (typeof val === 'string') {
          plugin.id = val;
        }
        if (plugin.worker != null) {
          if (typeof plugin.worker === 'string') {
            this.worker(plugin.worker);
          } else {
            log.warn('`worker` must be a file path: %O', plugin);
          }
        }
        if (typeof plugin.default === 'function') {
          plugin = plugin.default;
        }
        if (typeof plugin === 'function') {
          try {
            return (await plugin.call(this));
          } catch (error) {
            err = error;
            log.error(err);
          }
        }
      }));
    }

    worker(arg) {
      var frame;
      if (typeof arg === 'function') {
        frame = getCallSite(1);
        this._workers.push({
          func: arg.toString(),
          path: frame.getFileName(),
          line: frame.getLineNumber()
        });
        return;
      }
      if (typeof arg !== 'string') {
        throw TypeError('`worker` must be passed a filename or function');
      }
      if (!path.isAbsolute(arg)) {
        arg = path.resolve(path.dirname(getCallSite(1).getFileName()), arg);
      }
      this._workers.push({
        path: arg
      });
    }

    getSourceMapURL(arg) {
      return '\n\n' + this._wrapSourceMapURL(typeof arg === 'string' && arg + '.map' || arg.toUrl());
    }

    unload() {
      this._unload();
      this._result = null;
    }

    destroy() {
      this._result = Promise.resolve(null);
      this.main = null;
      this.assets = null;
      this.packages.forEach(function(pack) {
        var ref;
        return (ref = pack.watcher) != null ? ref.destroy() : void 0;
      });
      this.packages = null;
      this.project.drop(this);
      this.project = null;
      dropBundle(this);
      this.emitAsync('destroy');
    }

    _parseExt(name) {
      var match;
      if (match = this._extRE.exec(name)) {
        return match[0];
      }
    }

    _getInitialConfig() {
      var ctr, ref;
      ctr = this.constructor;
      return {
        exts: ((ref = ctr.exts) != null ? ref.slice(0) : void 0) || []
      };
    }

    _onConfigure() {
      this._extRE = extRegex(this.get('exts') || empty, this.get('known exts') || empty);
    }

    async _configure() {
      var err, events;
      this._config = this._getInitialConfig();
      this._events = events = {};
      if (this._init) {
        try {
          await this._init();
        } catch (error) {
          err = error;
          log.error(err);
        }
      }
      await this._callPlugins();
      await this.project._configure(this);
      if (events.config) {
        events.config.emit();
        events.config = null;
      }
      this._onConfigure();
      loadBundle(this);
      return this;
    }

    _callPlugins() {
      if (this.plugins.length) {
        return this.use(this.plugins);
      }
    }

    async _build() {
      var bundle, err, time;
      try {
        this.valid = true;
        this.state = {};
        await (this._loading || (this._loading = this._configure()));
        if (!this.valid) {
          return null;
        }
        time = process.hrtime();
        bundle = (await build(this, this.state));
        if (!this.valid) {
          return null;
        }
        time = process.hrtime(time);
        this.state.elapsed = Math.ceil(time[0] * 1e3 + time[1] * 1e-6);
        return bundle;
      } catch (error) {
        err = error;
        // Errors are ignored when the next build is automatic.
        if (this.valid) {
          this._result = null;
          this._invalidate();
          throw err;
        }
      }
    }

    // Invalidate the current build, and disable automatic rebuilds
    // until the next build is triggered manually.
    _invalidate() {
      this.valid = false;
      this.emitAsync('invalidate');
    }

    // Schedule an automatic rebuild.
    _rebuild() {
      if (this._result) {
        if (this.valid) {
          this._invalidate();
        }
        return this._result = this._result.then(noEarlier(200 + Date.now())).then(this._build.bind(this));
      }
    }

    _unload() {
      if (this.valid) {
        this._invalidate();
      }
      // Reset the main module.
      this.main.content = null;
      this.main.deps = null;
      // Reset the asset cache.
      this.assets = [, this.main];
      this._nextAssetId = 2;
      // Reset the root package.
      this.root.crawled = false;
      this.root.assets = Object.create(null);
      this.root.assets[this.main.name] = this.main;
      this.root.users = new Set;
      // Reset the package cache.
      this.packages = Object.create(null);
      this.packages[this.root.data.name] = new Map([[this.root.data.version, this.root]]);
      this._loading = null;
      this._loadedPlugins.clear();
    }

    _loadAsset(name, pack) {
      var asset, assetId;
      assetId = this._nextAssetId++;
      this.assets[assetId] = asset = new Asset(assetId, name, pack);
      pack.assets[name] = asset;
      return asset;
    }

    _loadPackage(root, data) {
      var pack, versions;
      if (!path.isAbsolute(root)) {
        throw Error(`Package root must be absolute: '${root}'`);
      }
      if (!(data || (data = evalFile(path.join(root, 'package.json'))))) {
        uhoh('Missing package.json', 'NOT_PACKAGE');
      }
      if (!data.name) {
        uhoh('Package has no "name" field', 'NO_NAME');
      }
      if (!data.version) {
        uhoh('Package has no "version" field', 'NO_VERSION');
      }
      if (versions = this.packages[data.name]) {
        if (pack = versions.get(data.version)) {
          return pack;
        }
      } else {
        this.packages[data.name] = versions = new Map;
      }
      versions.set(data.version, pack = new Package(root, data));
      root = fs.follow(root, true);
      if (!nodeModulesRE.test(root)) {
        pack._watch(root);
      }
      pack.bundle = this;
      return pack;
    }

    _concat() {
      throw Error('Bundle format must override `_concat`');
    }

    _wrapSourceMapURL() {
      throw Error('Bundle format must override `_wrapSourceMapURL`');
    }

  };

  Bundle.Asset = Asset;

  Bundle.Package = Package;

  return Bundle;

}).call(this);

require('./PluginMixin')(Bundle);

module.exports = Bundle;


// Helpers

// Create a function that enforces a minimum delay.
noEarlier = function(time) {
  return function() {
    return new Promise(function(resolve) {
      var delay;
      delay = Math.max(0, time - Date.now());
      return delay && setTimeout(resolve, delay) || resolve();
    });
  };
};

resolvePlugin = async function(name, main) {
  var plugin;
  if (name.indexOf('cush-') === -1) {
    name = 'cush-plugin-' + name;
  }
  plugin = tryRequire(name, getModule(main));
  plugin || (plugin = (await lazyRequire(name)));
  return plugin;
};

tryRequire = function(request, parent) {
  var filename;
  try {
    filename = Module._resolveFilename(request, parent);
  } catch (error) {}
  if (filename) {
    return parent.require(filename);
  }
};
