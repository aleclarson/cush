// Generated by CoffeeScript 2.3.0
var Asset, BUSY, Bundle, DONE, Emitter, IDLE, INIT, LAZY, Module, Package, REDO, build, cssParser, cush, dropBundle, each, empty, evalFile, extRegex, fs, getCallSite, getModule, isObject, jsParser, loadBundle, log, noEarlier, nodeModulesRE, path, resolvePlugin, resolved, tryRequire, uhoh, wait;

({each, evalFile, extRegex, getCallSite, getModule, uhoh} = require('../utils'));

({loadBundle, dropBundle} = require('../workers'));

isObject = require('is-object');

Emitter = require('@cush/events');

Package = require('./Package');

Module = require('module');

Asset = require('./Asset');

build = require('./build');

cush = require('cush');

path = require('path');

log = require('lodge').debug('cush');

fs = require('saxon/sync');

empty = [];

resolved = Promise.resolve(null);

nodeModulesRE = /\/node_modules\//;

jsParser = require.resolve('../parsers/js');

cssParser = require.resolve('../parsers/css');

INIT = 1; // never built before

LAZY = 2; // no automatic rebuilds

IDLE = 3; // waiting for changes

REDO = 4; // scheduled to rebuild

BUSY = 5; // build in progress

DONE = 6; // build complete

Bundle = (function() {
  class Bundle extends Emitter {
    constructor(opts) {
      super();
      this.id = opts.id;
      this.dev = Boolean(opts.dev);
      this.root = null;
      this.main = null;
      this.target = opts.target;
      this.assets = [];
      this.packages = Object.create(null);
      this.plugins = opts.plugins || [];
      this.project = null;
      this.status = INIT;
      this.state = null;
      this.time = 0;
      this._extRE = null;
      this._config = null;
      this._events = null;
      this._workers = [];
      this._loading = null;
      this._loadedPlugins = new Set;
      this._nextAssetId = 1;
      this._result = null;
    }

    relative(absolutePath) {
      return absolutePath.slice(this.root.path.length + 1);
    }

    resolve(relativePath) {
      return path.resolve(this.root.path, relativePath);
    }

    read() {
      if (this.status <= IDLE) {
        if (this._result === null) {
          return this._result = this._build();
        } else {
          return this._result = this._result.then(this._build.bind(this));
        }
      } else {
        return this._result;
      }
    }

    use(plugins) {
      if (!Array.isArray(plugins)) {
        plugins = [plugins];
      }
      return Promise.all(plugins.map(async(val) => {
        var err, plugin;
        if (Array.isArray(val)) {
          return this.use(val);
        }
        plugin = typeof val === 'string' ? (await resolvePlugin(val, this.main.path())) : val;
        if (!plugin || this._loadedPlugins.has(plugin)) {
          return;
        }
        this._loadedPlugins.add(plugin);
        if (typeof val === 'string') {
          plugin.id = val;
        }
        if (plugin.worker != null) {
          if (typeof plugin.worker === 'string') {
            this.worker(plugin.worker);
          } else {
            log.warn('`worker` must be a file path: %O', plugin);
          }
        }
        if (typeof plugin.default === 'function') {
          plugin = plugin.default;
        }
        if (typeof plugin === 'function') {
          try {
            return (await plugin.call(this));
          } catch (error) {
            err = error;
            log.error(err);
          }
        }
      }));
    }

    worker(arg) {
      var frame;
      if (typeof arg === 'function') {
        frame = getCallSite(1);
        this._workers.push({
          func: arg.toString(),
          path: frame.getFileName(),
          line: frame.getLineNumber()
        });
        return;
      }
      if (typeof arg !== 'string') {
        throw TypeError('`worker` must be passed a filename or function');
      }
      if (!path.isAbsolute(arg)) {
        arg = path.resolve(path.dirname(getCallSite(1).getFileName()), arg);
      }
      this._workers.push({
        path: arg
      });
    }

    getSourceMapURL(arg) {
      return '\n\n' + this._wrapSourceMapURL(typeof arg === 'string' && arg + '.map' || arg.toUrl());
    }

    unload() {
      this.status = LAZY;
      if (this.status > IDLE) {
        this._result.then(this._unload.bind(this));
      } else {
        this._unload();
      }
    }

    destroy() {
      this.emitAsync('destroy');
      this.project.drop(this);
      this.project = null;
      this.unload();
      this._result = resolved;
    }

    _parseExt(name) {
      var match;
      if (match = this._extRE.exec(name)) {
        return match[0];
      }
    }

    _getInitialConfig() {
      var ctr, ref;
      ctr = this.constructor;
      return {
        exts: ((ref = ctr.exts) != null ? ref.slice(0) : void 0) || []
      };
    }

    _onConfigure() {
      this._extRE = extRegex(this.get('exts') || empty, this.get('known exts') || empty);
    }

    async _configure() {
      var events;
      this._config = this._getInitialConfig();
      this._events = events = {};
      // Add the built-in parsers.
      this.merge('parsers', [jsParser, cssParser]);
      // Call format-provided plugins.
      if (this.constructor.plugins) {
        await this.use(this.constructor.plugins);
      }
      // Call plugins provided during creation.
      if (this.plugins.length) {
        await this.use(this.plugins);
      }
      // Apply `cush.config.js` configuration.
      await this.project._configure(this);
      if (events.config) {
        events.config.emit();
        events.config = null;
      }
      this._onConfigure();
      loadBundle(this);
      return this;
    }

    async _build() {
      var bundle, err, time;
      if (this.status !== INIT) {
        this.emitSync('rebuild');
      }
      this.state = {};
      this.status = BUSY;
      try {
        await (this._loading || (this._loading = this._configure()));
        if (this.status !== BUSY) {
          return null;
        }
        time = Date.now();
        bundle = (await build(this, this.state));
        if (this.status !== BUSY) {
          return null;
        }
        this.time = time;
        this.status = DONE;
        return bundle;
      } catch (error) {
        err = error;
        if (this.status !== BUSY) {
          return null;
        }
        this.status = LAZY;
        this._result = resolved;
        throw err;
      }
    }

    // Schedule an automatic rebuild.
    _invalidate(reload) {
      if (this.status > REDO || this.status === IDLE) {
        this.status = REDO;
        this.emitAsync('invalidate');
        this._result = this._result.then(noEarlier(Date.now() + 100)).then(() => {
          if (reload) {
            this._unload();
          }
          return this._build();
        });
      }
    }

    _unload() {
      dropBundle(this);
      // Reset the main module.
      this.main.content = null;
      this.main.deps = null;
      // Clear the asset cache.
      this.assets = [, this.main];
      this._nextAssetId = 2;
      // Reset the root package.
      this.root.crawled = false;
      this.root.assets = Object.create(null);
      this.root.assets[this.main.name] = this.main;
      this.root.users = new Set;
      // Unwatch all packages (except the project root).
      each(this.packages, (pack) => {
        var ref;
        if (pack !== this.root) {
          if ((ref = pack.watcher) != null) {
            ref.destroy();
          }
        }
      });
      // Clear the package cache.
      this.packages = Object.create(null);
      this.packages[this.root.data.name] = new Map([[this.root.data.version, this.root]]);
      this._loading = null;
      this._loadedPlugins.clear();
    }

    _loadAsset(name, pack) {
      var asset, assetId;
      assetId = this._nextAssetId++;
      this.assets[assetId] = asset = new Asset(assetId, name, pack);
      pack.assets[name] = asset;
      return asset;
    }

    _loadPackage(root, data) {
      var pack, versions;
      if (!path.isAbsolute(root)) {
        throw Error(`Package root must be absolute: '${root}'`);
      }
      if (!(data || (data = evalFile(path.join(root, 'package.json'))))) {
        uhoh('Missing package.json', 'NOT_PACKAGE');
      }
      if (!data.name) {
        uhoh('Package has no "name" field', 'NO_NAME');
      }
      if (!data.version) {
        uhoh('Package has no "version" field', 'NO_VERSION');
      }
      if (versions = this.packages[data.name]) {
        if (pack = versions.get(data.version)) {
          return pack;
        }
      } else {
        this.packages[data.name] = versions = new Map;
      }
      versions.set(data.version, pack = new Package(root, data));
      root = fs.follow(root, true);
      if (!nodeModulesRE.test(root)) {
        pack._watch(root);
      }
      pack.bundle = this;
      return pack;
    }

    _concat() {
      throw Error('Bundle format must override `_concat`');
    }

    _wrapSourceMapURL() {
      throw Error('Bundle format must override `_wrapSourceMapURL`');
    }

  };

  Bundle.Asset = Asset;

  Bundle.Package = Package;

  Bundle.Status = {INIT, LAZY, IDLE, REDO, BUSY, DONE};

  return Bundle;

}).call(this);

require('./PluginMixin')(Bundle);

module.exports = Bundle;


// Helpers

// Create a function that enforces a minimum delay.
noEarlier = function(time) {
  return function() {
    return wait(time - Date.now());
  };
};

wait = function(ms) {
  return new Promise(function(resolve) {
    if (ms > 0) {
      return setTimeout(resolve, ms);
    } else {
      return resolve();
    }
  });
};

resolvePlugin = async function(name, main) {
  var plugin;
  if (name.indexOf('cush-') === -1) {
    name = 'cush-plugin-' + name;
  }
  plugin = tryRequire(name, getModule(main));
  plugin || (plugin = (await lazyRequire(name)));
  return plugin;
};

tryRequire = function(request, parent) {
  var filename;
  try {
    filename = Module._resolveFilename(request, parent);
  } catch (error) {}
  if (filename) {
    return parent.require(filename);
  }
};
