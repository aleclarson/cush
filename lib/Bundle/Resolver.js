// Generated by CoffeeScript 2.3.1
var Resolver, cush, log, path, relative, resolveMain, scopedRE;

relative = require('@cush/relative');

cush = require('cush');

path = require('path');

log = require('lodge').debug('cush');

scopedRE = /^((?:@[a-z._-]+\/)?[a-z._-]+)(?:\/(.+))?$/;

Resolver = function(bundle, resolved, missing) {
  var exts, resolveImport, target;
  ({target} = bundle);
  exts = bundle.get('exts');
  resolveImport = function(parent, ref) {
    var asset, id, isMain, match, owner, pack;
    ({owner} = parent);
    // ./ or ../
    if (ref[0] === '.') {
      id = relative(parent.name, ref);
      if (id === null) {
        cush.emit('warning', {
          message: 'Unsupported import path: ' + ref,
          parent: bundle.relative(parent.path())
        });
        return false;
      }
      if (id === '') {
        // use the main module if referencing package root
        id = resolveMain(owner, bundle);
        isMain = true;
      }
    } else if (!path.isAbsolute(ref)) {
      if (match = scopedRE.exec(ref)) {
        if (!(pack = owner.require(match[1]))) {
          if (process.env.DEBUG) {
            log.warn('Failed to resolve %O from %O', ref, bundle.relative(parent.path()));
          }
          owner.missedPackage = true;
          return false;
        }
        if (!(id = match[2])) {
          // use the main module if nothing follows the package name
          id = resolveMain(pack, bundle);
          isMain = true; // absolute paths are forbidden ğŸ’¥
        }
      }
    } else {
      cush.emit('warning', {
        message: 'Import path must be relative',
        parent: bundle.relative(parent.path())
      });
      return false;
    }
    pack || (pack = owner);
    if (isMain && pack.main) {
      return pack.main;
    }
    pack.crawl();
    if (asset = pack.search(id, target, exts)) {
      if (isMain) {
        pack.main = asset;
      }
      return asset;
    }
    if (process.env.DEBUG) {
      log.warn('Failed to resolve %O from %O', ref, bundle.relative(parent.path()));
    }
    pack.missedAsset = true;
    return false;
  };
  // Resolve all dependencies of an asset.
  return function(parent) {
    var assets;
    assets = {};
    parent.deps.forEach(function(dep, i) {
      var asset, ref;
      ({ref, asset} = dep);
      if (!asset || !asset.id || asset.time > bundle.time) {
        asset = assets[ref];
        // Never resolve the same ref twice.
        if (asset === void 0) {
          assets[ref] = asset = resolveImport(parent, ref);
          if (asset) {
            dep.asset = asset;
            resolved.push(asset);
            return;
          }
        } else if (asset) {
          dep.asset = asset;
          return;
        }
        // The asset cannot be found.
        missing.push([parent, dep]);
        return;
      }
      if (!assets[ref]) {
        assets[ref] = asset;
        resolved.push(asset);
      }
    });
    // Return the ordered assets.
    return assets;
  };
};

module.exports = Resolver;

// Resolve the main module of a package.
resolveMain = function(pack, bundle) {
  var id;
  if (bundle._config.browser !== false) {
    id = pack.data.browser;
  }
  if (id || (id = pack.data.main)) {
    if (id[0] === '.') {
      return relative('', id);
    } else {
      return id;
    }
  } else {
    return 'index';
  }
};
